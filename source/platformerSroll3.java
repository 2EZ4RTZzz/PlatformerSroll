/* autogenerated by Processing revision 1286 on 2022-11-25 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import ddf.minim.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class platformerSroll3 extends PApplet {



float speed = 2;
float upSpeed = 20;
PVector upForce = new PVector(0, -speed * 20);
PVector upForcePower = new PVector(0, -speed * 30);
PVector leftForce = new PVector(-speed, 0);
PVector rightForce = new PVector(speed, 0);
boolean up, left, right;
float grav = 2;
PVector gravForce = new PVector(0, grav);
int repeatX=2;
int playerLifeNum = 3;

Player player;
ArrayList<Block> blocks = new ArrayList<Block>();
ArrayList<Token> tokens = new ArrayList<Token>();
ArrayList<Character> enemies = new ArrayList<Character>();
ArrayList<Cloud> clouds = new ArrayList<Cloud>();

Explosion explosion;



Background bg;


//int countdown;




 public void drawHUD() {
  for (int i = 0; i < playerLifeNum; i++) {
    image(heartImgs[0], 50 + (heartImgs[0].width + 5) * i, 20);
  }

  pushStyle();
  noStroke();
  fill(255, 0, 0);
  rect(50, 50, map(player.health, 0, player.maxHealth, 0, 100), 10, 10);
  stroke(0);
  strokeWeight(3);
  noFill();
  rect(50, 50, 100, 10, 10);
  popStyle();

  image(keyImgs[0], width - 300, 20);
  text(player.amountOfKey, width - 270, 50);
  image(coinImgs[0], width - 200, 20);
  text(player.amountOfCoin, width - 170, 50);
}

 public void loadAllBlocks() {
  blocks.add(new WaterBlock(new PVector(540, height - 10), 7, waterImgs));
  blocks.add(new GroundBlock(new PVector(groundImgs[0].width * 10 / 2, height - 20), 10, groundImgs));
  blocks.add(new Block(new PVector(200, height - 120), 3, plateformImgs));
  blocks.add(new Block(new PVector(360, height - 220), 3, plateformImgs));
  blocks.add(new GroundBlock(new PVector(880, height - 20), 10, groundImgs));
  blocks.add(new MovingBlock(new PVector(600, height - 140), 3, 0, plateformImgs));
  blocks.add(new Block(new PVector(750, height - 240), 3, plateformImgs));
  blocks.add(new Block(new PVector(830, height - 320), 3, plateformImgs));
  blocks.add(new Block(new PVector(940, height - 500), 3, plateformImgs));
  blocks.add(new SpringBlock(new PVector(850, height - 345), 1, springImgs));
  blocks.add(new MovingBlock(new PVector(1150, height - 345), 2, 1, plateformImgs));
  blocks.add(new GroundBlock(new PVector(1350, height - 20), 5, groundImgs));
  blocks.add(new MovingBlock(new PVector(1350, height - 400), 4, 2, shroomRedImgs));
  blocks.add(new MovingBlock(new PVector(1550, height - 345), 2, 1, plateformImgs));
}


 public void setup() {
  /* size commented out by preprocessor */;
  stroke(200);
  strokeWeight(2);
  fill(63);
  //player = new Character(new PVector(width/4, height/4));
  loadAllImages();
  player = new Player(new PVector(20, 50));
  player.jumping = true;

  bg = new Background("bg.png", 2, 1, 0.5f);


  clouds.add(new Cloud(cloud1Img));
  clouds.add(new Cloud(cloud2Img));
  clouds.add(new Cloud(cloud3Img));


  loadAllBlocks();

  //tokens.add(new Heart(blocks.get(2), new PVector(-50, -80)));
  tokens.add(new Key(blocks.get(8), new PVector(0, -40)));

  enemies.add(new Snail(blocks.get(2), new PVector(30, -17)));
  enemies.add(new Snail(blocks.get(3), new PVector(30, -17)));
  enemies.add(new Snail(blocks.get(4), new PVector(random(-160, 160), -28)));
  enemies.add(new Snail(blocks.get(4), new PVector(random(-160, 160), -28)));
  enemies.add(new Snail(blocks.get(4), new PVector(random(-160, 160), -28)));
  enemies.add(new Snail(blocks.get(4), new PVector(random(-160, 160), -28)));
  enemies.add(new Alian(blocks.get(8), new PVector(random(-30, 30), -30)));
  
  enemies.add(new Fish(blocks.get(0), new PVector(random(-30, 20), 0)));
  enemies.add(new Fish(blocks.get(0), new PVector(random(-30, 10), 0)));
  enemies.add(new Fish(blocks.get(0), new PVector(random(-30, 15), 0)));
  enemies.add(new Fish(blocks.get(0), new PVector(random(-30, 15), 0)));
  enemies.add(new Fish(blocks.get(0), new PVector(random(-30, 15), 0)));
  //enemies.add(new Alian(blocks.get(2), new PVector(30, -32)));
  //enemies.add(new Alian(blocks.get(5), new PVector(30, -32)));
  //enemies.add(new Alian(blocks.get(6), new PVector(30, -32)));
  //enemies.add(new Alian(blocks.get(4), new PVector(-50, -45)));
  //enemies.add(new Alian(blocks.get(4), new PVector(-30, -45)));
  //enemies.add(new Alian(blocks.get(4), new PVector(30, -45)));

  loadAllAudios();

  //bgMusic.loop();
}

 public void draw() {
  //image(bgImg, 0, 0);
  bg.drawMe(new PVector(-player.pos.x, 0));

  //player.detectFloor();
  drawHUD();

  for (Cloud c : clouds) {
    c.update();
  }

  if (up && !player.jumping) {
    if (player.block instanceof SpringBlock) player.jump(upForcePower);
    else player.jump(upForce);
  }
  if (left) player.move(leftForce);
  if (right) player.move(rightForce);


  //leave the current block
  if (player.block != null) {
    if (!player.block.isOn(player)) {
      player.jumping = true;
    }
  }

  //println(player.jumping);

  if (player.jumping) {

    player.move(gravForce);
    for (int i = 0; i < blocks.size(); i++) {
      Block b = blocks.get(i);
      if (b.bump(player)) {
        if (b instanceof WaterBlock) {
          player.decreaseHealth(0.2f);
          player.pos.y = height - player.dim.y / 2;
        } else {
          if (player.vel.y >= 0) {
            if (b instanceof DisintegrateBlock) {
              if (((DisintegrateBlock)b).solid == true) {
                player.landOn(b);
              }
            } else {
              player.landOn(b);
            }
          } else {
            if (!(b instanceof SpringBlock) && !(b instanceof MovingBlock)) {
              player.pos.y = b.pos.y + b.dim.y / 2 + player.dim.y / 2;
              player.fall();
            }
          }
        }
      }
    }
  }


  if (player.pos.x > width) player.pos.x = 20;  //if player is going off screen make it start from the begining to keep scrolling
  if (player.pos.x - player.imgs[0].width / 2 <= 0) player.pos.x = player.imgs[0].width / 2;  //if player is going off screen make it start from the begining to keep scrolling
  
   for (int i = 0; i < enemies.size(); i++) {
    Character e = enemies.get(i);
    e.drawMe(player);
    e.update();
    if (e.deadCountdown == 0) {
      enemies.remove(e);
      continue;
    }

    if (e.collision(player)) {
      if (player.hitCountdown == 0) {
        player.hitCountdown = 60;
        hurtSound.play(0);
      }
      player.decreaseHealth(1);
    }
  }

  for (int i = 0; i < blocks.size(); i++) {
    Block b = blocks.get(i);
    b.drawMe(player);
    b.update();
    if (b instanceof MovingBlock) {
      ((MovingBlock)b).move();
    }
  }
  

  for (int i = 0; i < tokens.size(); i++) {
    Token t = tokens.get(i);
    t.drawMe(player);
    t.update();
    
    if (t.displayCountdown == 0){
       tokens.remove(t);
       continue; 
    }
    if (t.collision(player)) {
      hitTokenSound.play(0);
      if (t instanceof Heart) {
        playerLifeNum += 1;
      }
      if (t instanceof Key) {
        player.amountOfKey += 1;
      }
      if (t instanceof Coin) {
        player.amountOfCoin += 1;
      }
      tokens.remove(t);
      explosion = new Explosion(new PVector(t.block.pos.x + t.relPos.x - player.pos.x * repeatX, t.block.pos.y + t.relPos.y));
    }
  }

  if (explosion != null) explosion.update();

  

  player.update();
  if (player.block instanceof MovingBlock) {
    MovingBlock b = (MovingBlock)player.block;
    if (b.direction == 2) {
      player.drawMe2();
    } else {
      player.drawMe();
    }
  } else {
    player.drawMe();
  }
  
  if (player.amountOfCoin == 15){
    player.amountOfCoin -= 15;
    tokens.add(new Heart(blocks.get(10), new PVector(0, -40)));
  }
}
class Alian extends Character {
  //fields

  ArrayList<Bullet> bullets = new ArrayList<Bullet>();
  //a constructor to initialize the fields above with initial values
  Alian(Block b, PVector rp) {
    super(rp);
    damp = 1;
    this.block = b;
    vel = new PVector(random(-1, -0.5f), 0); //must create instance
    imgs = catImgs;
    dim = new PVector(imgs[0].width, imgs[0].height);
    health = 3;
  }

  //update the physics for the character
   public void update() {
    super.update();

    if (pos.x + dim.x / 2 > block.dim.x / 2 || pos.x - dim.x / 2 < -block.dim.x / 2) {
      vel.x *= -1;
    }

    //println(dist(-player.pos.x*repeatX+block.pos.x + pos.x, block.pos.y, player.pos.x, player.pos.y));
    if (dist(-player.pos.x*repeatX+block.pos.x + pos.x, block.pos.y, player.pos.x, player.pos.y) < 120 && frameCount % 20 == 0 && vel.x < 0) {
      fireSound.play(0);
      fire();
    }

    checkBullets();
  }


   public void drawMe(Character c) {
    if (hitCountdown % 2 == 0) {
      pushMatrix();
      translate(-c.pos.x*repeatX+block.pos.x, block.pos.y);
      translate(pos.x, pos.y); //relative position to block stand on
      if (deadCountdown > 0) scale(map(deadCountdown, 0, 30, 0, 1));
      if (vel.x < 0) scale(-1, 1);

      if (frameCount % 5 == 0) index++;
      image(imgs[index%imgs.length], -dim.x / 2, -dim.y / 2);
      popMatrix();
    }
  }

   public void fire() {

    PVector loc;
    if (vel.x >= 0)  loc = new PVector(pos.x + 50, pos.y + 7);
    else loc = new PVector(-player.pos.x * repeatX + block.pos.x, block.pos.y + pos.y + 7);
    PVector speed = new PVector(-10, 0);

    bullets.add(new Bullet(loc, speed, "alian"));
  }

   public void checkBullets() {
    for (int i = 0; i < bullets.size(); i++) {
      Bullet b = bullets.get(i);
      b.drawMe();
      b.update();

      if (b.hit(player) && player.deadCountdown == -1) {
        player.decreaseHealth(100);
        player.hitCountdown = 60;

        if (player.health == 0) {
          player.dead(30);
        }
        bullets.remove(b);
      }
    }
  }
}
class Background {
  PImage img;
  int repeatX, repeatY;
  float speed;
  
//  Background(String path, int repeatX, int repeatY) {
  Background(String path, int repeatX, int repeatY, float speed) {
      img = loadImage(path);
      img.resize(img.width, height);
      this.repeatX = repeatX;
      this.repeatY = repeatY;
      this.speed = speed;
    }
//    void drawMe() {
//      PVector pos = new PVector(0, frameCount * 2);
     public void drawMe(PVector pos) {
      pos.mult(speed);

      int tilesX = -(floor(pos.x / img.width));
      //println(pos, speed, floor(pos.x / img.width));
      for (int i = tilesX-1; i < tilesX+repeatX; i++) {
          image(img, pos.x + img.width * i, pos.y);
      }
    }
  }
class Block {
  PVector pos, originalPos, dim;
  PImage[] imgs;
  int tileAmount;

  Block(PVector pos, int amount, PImage[] images) {
    this.pos = pos;
    tileAmount = amount;
    originalPos = new PVector(pos.x, pos.y);
    this.imgs = images;
    this.dim = new PVector(tileAmount * imgs[0].width, imgs[0].height);
  }
   public boolean isOn(Character c) {
    //if (abs(c.pos.x - pos.x) < c.dim.x / 2 + dim.x / 2) {
    if (abs(c.pos.x * repeatX - (pos.x-c.pos.x)) < c.dim.x / 2 + dim.x / 2) {
      return true;
    }
    return false;
  }
   public boolean bump(Character c) {
    if (abs(c.pos.x * repeatX - (pos.x-c.pos.x)) < c.dim.x / 2 + dim.x / 2 &&
      //if (abs(c.pos.x - pos.x )< c.dim.x / 2 + dim.x / 2 &&
      abs(c.pos.y - pos.y) < c.dim.y / 2 + dim.y / 2) {
        //println("hit");
      return true;
    }
    return false;
  }

   public void drawMe(Character c) {
    pushMatrix();
    translate(-c.pos.x * repeatX + pos.x, pos.y);

    image(imgs[0], -dim.x / 2, -dim.y / 2);
    for (int i = 0; i < tileAmount - 2; i++) {
      image(imgs[1], -dim.x / 2 + (i + 1) * imgs[0].width, -dim.y / 2);
    }
    image(imgs[imgs.length - 1], dim.x / 2 - imgs[0].width, -dim.y / 2);
    popMatrix();
  }

   public void update() {
  }
}
class Bullet {
  PVector pos, originalPos;
  PVector vel;
  PVector dim;
  PImage[] imgs;
  String type;
  int index;

  Bullet(PVector pos, PVector vel, String type) {
    this.pos = pos;
    originalPos = pos.copy();
    this.vel = vel;
    this.type = type;
    
    if (type == "player"){
       //imgs = playerBulletImgs; 
    }
    
    if (type == "cat"){
       //imgs = catBulletImgs; 
    }
    //dim = new PVector(imgs[0].width, imgs[0].height);
    
    dim = new PVector(15, 4);
  }

   public void drawMe() {
    pushMatrix();
    translate(pos.x, pos.y);
    //if (vel.x > 0) {
    //  scale(-1, 1);
    //}
    //image(imgs[index], -dim.x / 2, -dim.y / 2);
    noStroke();
    if (type == "player") fill(255, 128 , 0);
    if (type == "alian") fill(128, 128 , 255);
    rect(-dim.x / 2, -dim.y / 2, dim.x, dim.y, 5);
    popMatrix();
  }
  
   public void move(){
     pos.add(vel); 
  }
  
   public void update(){
     move();
     if (detectRange()){
       player.bullets.remove(this);
     }
  }
  
   public boolean detectWall(){
    if (pos.x + dim.x / 2 > width || pos.x - dim.x / 2 < 0 || pos.y + dim.y / 2 > height || pos.y - dim.y / 2 < 0){
      return true;
    }
    return false;
  }
  
   public boolean detectRange(){
    if (pos.x + dim.x / 2 > width || pos.x - dim.x / 2 < 0 || pos.y + dim.y / 2 > height || pos.y - dim.y / 2 < 0){
      return true;
    }
    if (pos.x > originalPos.x + random(180, 200)){
      return true;
    }
    return false;
  }
  
   public boolean hit(Character target){
    float x = target.block.pos.x-player.pos.x * repeatX+target.pos.x;
    float y = target.block.pos.y+target.pos.y;
    
    //println(x, y, pos.x, pos.y);
    return dist(x, y, pos.x, pos.y) < dim.x/2+target.dim.x/2;
    
  }
}
class Character {
  //fields
  PVector pos, relPos, vel, dim;
  float damp = 1; //constant damping factor

  Block block = null;

  float health;
  float maxHealth;
  PImage[] imgs;
  int index;
  int hitCountdown;
  int deadCountdown = -1;
  float sc = 1;
  //float sc;

  //a constructor to initialize the fields above with initial values
  Character(PVector pos) {
    this.pos = pos;
    vel = new PVector(); //must create instance
    dim = new PVector();
  }
  //move method, PVector force as parameter, add to acceleration
   public void move(PVector acc) {
    vel.add(acc);
  }

  //update the physics for the character
   public void update() {
    vel.x *= pow(damp, 4); //multiply velocity by dampening factor (0.9-0.99);
    vel.y *= damp; //multiply velocity by dampening factor (0.9-0.99);
    pos.add(vel); //add velocity to position (moves character)
    
    if (block != null){
       relPos = new PVector(pos.x - block.pos.x + pos.x * repeatX, pos.y - block.pos.y);
    }
    
    if (deadCountdown > 0) deadCountdown--;
    if (hitCountdown > 0) hitCountdown--;
  }

   public void drawMe() {
    pushMatrix();
    translate(pos.x, pos.y);
    ellipse(0, 0, dim.x, dim.y);
    popMatrix();
  }
  
   public void drawMe(Character c){
    
  }
  
   public void decreaseHealth(float n){
     health -= n;
     if (health < 0) health = 0;
  }
  
   public boolean collision(Character c) {
    float x = block.pos.x-c.pos.x*repeatX+pos.x;
    float y = block.pos.y+pos.y;
    //println(x, y, c.pos.x, c.pos.y);
    return dist(x, y, c.pos.x, c.pos.y) < dim.x/2+c.dim.y/2;
  }
  
   public void dead(int n){
     deadCountdown = n; 
     vel.mult(0);
  }
}
class Cloud{
   PVector pos;
   PVector vel;
   PImage img;
   float sc;
   
   Cloud(PImage img){
     this.pos = new PVector(random(width), random(20, height / 3));
     vel = new PVector(random(0.1f, 0.3f), 0);
     this.img = img;
     sc = random(0.5f, 1);
   }
   
    public void drawMe(){
      pushMatrix();
      translate(pos.x, pos.y);
      scale(sc);
      image(img, -img.width / 2, -img.height / 2);
      popMatrix();
   }
   
    public void move(){
      pos.add(vel); 
   }
   
    public void update(){
      drawMe();
      move();
      detectWall();
   }
   
    public void detectWall(){
      if (pos.x - img.width / 2 > width) {
         pos.x = - img.width / 2; 
      }
      
      if (pos.x + img.width / 2 < 0) {
         pos.x = width + img.width / 2; 
      }
   }
}
class Coin extends Token{
  

  Coin(Block block, PVector rp) {
    super(block, rp);
    imgs = coinImgs;
    dim = new PVector(imgs[0].width, imgs[0].height);
  
  }

   public void drawMe(Character c) {
    noStroke();
    pushMatrix();
    translate(-c.pos.x*repeatX+block.pos.x, block.pos.y);
    translate(relPos.x, relPos.y);
    image(imgs[index], -dim.x / 2, -dim.y / 2);
    popMatrix();
  }

  //boolean colission(Character c) {
  //  float x = block.pos.x-c.pos.x * repeatX+relPos.x;
  //  float y = block.pos.y+relPos.y;
  //  return dist(x, y, c.pos.x, c.pos.y) < dim.x/2+c.dim.y/2;
  //}
}
class Explosion{
   PVector pos;
   ArrayList<Sprite> balls = new ArrayList<Sprite>();
   
   Explosion(PVector pos){
       this.pos = pos;
       
       for (int i = 0; i < 30; i++){
           balls.add(new Sprite(new PVector(pos.x, pos.y)));
       }
   }
   
    public void update(){
       for (int i = 0; i < balls.size(); i++){
           Sprite s = balls.get(i);
           s.drawMe();
           s.update();
           if (s.dim.x == 0) balls.remove(s);
       }
   }
}
class Fish extends Character {
  //fields
  boolean jump;
  PVector g = new PVector(); //gravity
  int red,green,blue;
  

  //a constructor to initialize the fields above with initial values
  Fish(Block b, PVector rp) {
    super(rp);
    damp = 1;
    this.block = b;
    vel = new PVector(random(-0.8f, 0.8f), 0); //must create instance
    imgs = fishImgs;
    dim = new PVector(imgs[0].width, imgs[0].height);
    health = 1;
    sc = random(0.5f, 1);
    red = PApplet.parseInt(random(128));
    green = PApplet.parseInt(random(128));
    blue = 255;
  }

  //update the physics for the character
   public void update() {
    super.update();
    vel.add(g);
    
    if (pos.x + dim.x / 2 > block.dim.x / 2 || pos.x - dim.x / 2 < -block.dim.x / 2) {
      vel.x *= -1;
    }
    
    float n = random(1, 500);
    if (n < 2 && jump == false){
       jump = true;
       vel.y = random(-5, -20);
       vel.x *= 3;
       g = new PVector(0, 0.3f);
    }
    
    if (pos.y > 0) {
      jump = false;
      g.mult(0);
      vel.y = 0;
      vel.x /= 3;
      pos.y = random(0, -5);
    }
  }


   public void drawMe(Character c) {
    if (hitCountdown % 2 == 0){
      pushMatrix();
      translate(-c.pos.x*repeatX+block.pos.x, block.pos.y);
      translate(pos.x, pos.y); //relative position to block stand on
      scale(sc);
      rotate(vel.heading() + PI);
      
      if (deadCountdown > 0) scale(map(deadCountdown, 0, 30, 0, 1));
      if (vel.x > 0) scale(1, -1);
      
      if (frameCount % 5 == 0) index++;
      pushStyle();
      tint(red, green, blue);
      image(imgs[index%imgs.length], -dim.x / 2, -dim.y / 2);
      popStyle();
      popMatrix();
    }
  }
}
class GroundBlock extends Block{
  int mrAmt = PApplet.parseInt(random(2, 10));
  PVector[] mrPosArr = new PVector[mrAmt];
  int[] mrIndexsArr = new int[mrAmt];
  int bushAmount = PApplet.parseInt(random(1, 3));
  PVector[] bushPosArr = new PVector[bushAmount];
  float[] bushPosScArr = new float[bushAmount];

  
  GroundBlock(PVector pos, int amount, PImage[] images) {
    super(pos, amount, images);
    for (int i = 0; i < mrPosArr.length; i++){
      mrPosArr[i] = new PVector(random(-dim.x / 2 + 20, dim.x / 2-20), -dim.y / 2 - tinyMushroomImgs[0].height);
    }
    
    for (int i = 0; i < mrIndexsArr.length; i++){
      mrIndexsArr[i] = PApplet.parseInt(random(tinyMushroomImgs.length));
    }
    
    for (int i = 0; i < bushPosScArr.length; i++){
      bushPosScArr[i] = random(0.5f, 1.5f);
    }
    
    for (int i = 0; i < bushPosArr.length; i++){
      bushPosArr[i] = new PVector(random(-dim.x / 2 , dim.x / 2-bushImg.width / 2 * bushPosScArr[i]), -dim.y / 2);
    }
    
    

  }
 
   public void drawMe(Character c) {
    super.drawMe(c);
    
    pushMatrix();
    translate(-c.pos.x * repeatX + pos.x, pos.y);
    
    for (int i = 0; i < bushPosArr.length; i++){
      pushMatrix();
      scale(bushPosScArr[i]);
      //println(bushPosArr[i].x , bushPosArr[i].y );
      image(bushImg, bushPosArr[i].x , bushPosArr[i].y );
      popMatrix();
    }
    popMatrix();
    
    
    

    pushMatrix();
    translate(-c.pos.x * repeatX + pos.x, pos.y);
   
    for (int i = 0; i < mrPosArr.length; i++){
      //println(mrIndexsArr[i]);
      image(tinyMushroomImgs[mrIndexsArr[i]], mrPosArr[i].x, mrPosArr[i].y);
    }
    
    
    
    popMatrix();
  }
}
class Heart extends Token{
  

  Heart(Block block, PVector rp) {
    super(block, rp);
    imgs = heartImgs;
    dim = new PVector(imgs[0].width, imgs[0].height);
    displayCountdown = 1800;
  }

   public void drawMe(Character c) {
    noStroke();
    pushMatrix();
    translate(-c.pos.x*repeatX+block.pos.x, block.pos.y);
    translate(relPos.x, relPos.y);
    fill(255);
    textSize(15);
    textAlign(CENTER, CENTER);
    text(displayCountdown / 60 + 1, 0, -25);
    image(imgs[index], -dim.x / 2, -dim.y / 2);
    popMatrix();
  }

  //boolean colission(Character c) {
  //  float x = block.pos.x-c.pos.x * repeatX+relPos.x;
  //  float y = block.pos.y+relPos.y;
  //  return dist(x, y, c.pos.x, c.pos.y) < dim.x/2+c.dim.y/2;
  //}
}
class Key extends Token{
  

  Key(Block block, PVector rp) {
    super(block, rp);
    imgs = keyImgs;
    dim = new PVector(imgs[0].width, imgs[0].height);
  
  }

   public void drawMe(Character c) {
    noStroke();
    pushMatrix();
    translate(-c.pos.x*repeatX+block.pos.x, block.pos.y);
    translate(relPos.x, relPos.y);
    image(imgs[index], -dim.x / 2, -dim.y / 2);
    popMatrix();
  }

  //boolean colission(Character c) {
  //  float x = block.pos.x-c.pos.x * repeatX+relPos.x;
  //  float y = block.pos.y+relPos.y;
  //  return dist(x, y, c.pos.x, c.pos.y) < dim.x/2+c.dim.y/2;
  //}
}
AudioPlayer bgMusic;
AudioPlayer jumpSound;
AudioPlayer fireSound;
AudioPlayer hitSound;
AudioPlayer hurtSound;
AudioPlayer hitTokenSound;
Minim minim;

 public void loadAllAudios(){
   minim = new Minim (this);
  bgMusic = minim.loadFile("audio/bgMusic.mp3");
  fireSound = minim.loadFile("audio/laser-gun.mp3");
  jumpSound = minim.loadFile("audio/jump.mp3"); 
  hurtSound = minim.loadFile("audio/hurt.wav"); 
  hitTokenSound = minim.loadFile("audio/hitToken.wav"); 
}
PImage[] playerWalkImgs = new PImage[11];
PImage[] playerJumpImgs = new PImage[1];
PImage[] playerDuckImgs = new PImage[1];
PImage[] playerStandImgs = new PImage[1];
PImage[] heartImgs = new PImage[2];
PImage[] keyImgs = new PImage[2];
PImage[] catImgs = new PImage[4];
PImage[] groundImgs = new PImage[3];
PImage[] plateformImgs = new PImage[3];
PImage[] waterImgs = new PImage[2];
PImage[] tinyMushroomImgs = new PImage[7];
PImage[] springImgs = new PImage[2];
PImage[] shroomRedImgs = new PImage[4];
PImage[] snailImgs = new PImage[2];
PImage[] fishImgs = new PImage[2];
PImage stemBaseImg;
PImage stemCrownImg;
PImage stemVineImg;
PImage bgImg;
PImage cloud1Img;
PImage cloud2Img;
PImage cloud3Img;
PImage playerGunImg;
PImage bushImg;
PImage[] coinImgs = new PImage[2];

 public void loadAllImages() {

  playerStandImgs[0] = loadImage("p3_stand.png");
  playerStandImgs[0].resize(72/2, 97/2);
  playerJumpImgs[0] = loadImage("p3_jump.png");
  playerJumpImgs[0].resize(72/2, 97/2);
  for (int i = 0; i < playerWalkImgs.length; i++) {
    playerWalkImgs[i] = loadImage("p3_walk" + i + ".png");
    playerWalkImgs[i].resize(72/2, 97/2);
  }

  for (int i = 0; i < heartImgs.length; i++) {
    heartImgs[i] = loadImage("heart" + i + ".png");
    heartImgs[i].resize(25, 25);
  }

  for (int i = 0; i < keyImgs.length; i++) {
    keyImgs[i] = loadImage("key" + i + ".png");
    keyImgs[i].resize(30, 30);
  }

  for (int i = 0; i < catImgs.length; i++) {
    catImgs[i] = loadImage("p1_walk" + i + ".png");
    catImgs[i].resize(72 / 2, 97 / 2);
  }

  for (int i = 0; i < groundImgs.length; i++) {
    groundImgs[i] = loadImage("ground" + i + ".png");
    groundImgs[i].resize(40, 40);
  }

  for (int i = 0; i < plateformImgs.length; i++) {
    plateformImgs[i] = loadImage("plateform" + i + ".png");
    plateformImgs[i].resize(40, 20);
  }

  for (int i = 0; i < waterImgs.length; i++) {
    waterImgs[i] = loadImage("water" + i + ".png");
    waterImgs[i].resize(40, 20);
  }

  for (int i = 0; i < tinyMushroomImgs.length; i++) {
    tinyMushroomImgs[i] = loadImage("mushroom" + i + ".png");
    tinyMushroomImgs[i].resize(40, 40);
  }

  for (int i = 0; i < springImgs.length; i++) {
    springImgs[i] = loadImage("spring" + i + ".png");
    springImgs[i].resize(30, 30);
  }

  for (int i = 0; i < shroomRedImgs.length; i++) {
    shroomRedImgs[i] = loadImage("shroomRed" + i + ".png");
    shroomRedImgs[i].resize(60, 60);
  }
  
  for (int i = 0; i < snailImgs.length; i++) {
    snailImgs[i] = loadImage("snailWalk" + i + ".png");
    snailImgs[i].resize(54*3/ 5, 31*3/5);
  }
  
  for (int i = 0; i < coinImgs.length; i++) {
    coinImgs[i] = loadImage("coin" + i + ".png");
    coinImgs[i].resize(20, 20);
  }
  
  for (int i = 0; i < fishImgs.length; i++) {
    fishImgs[i] = loadImage("fishSwim" + i + ".png");
    fishImgs[i].resize(62 / 3, 43 / 3);
  }

  bgImg = loadImage("bg.png");
  bgImg.resize(width, height);

  cloud1Img = loadImage("cloud1.png");
  cloud2Img = loadImage("cloud1.png");
  cloud3Img = loadImage("cloud1.png");

  stemBaseImg = loadImage("stemBase.png");
  stemCrownImg = loadImage("stemCrown.png");
  stemVineImg = loadImage("stemVine.png");

  playerGunImg = loadImage("raygun.png");
  playerGunImg.resize(40, 40);
  
  bushImg = loadImage("bush.png");
  bushImg.resize(216 / 2, 72/ 2);
  
}
class MovingBlock extends Block{
  PVector vel;
  int direction; //0 is horizental, 1 is vertical
  float offset;
  float angle;
  float angle_speed;
 
  MovingBlock (PVector pos, int amount, int d, PImage[] images) {
    super(pos, amount, images);
    direction = d;
    if (direction == 0) vel = new PVector(-1, 0);
    if (direction == 1) vel = new PVector(0, 2);
    if (direction == 2) {
      vel = new PVector();
      angle_speed = 0.5f;
    }
    offset = 100;
  }
  
   public void drawMe(Character c) {
    pushMatrix();
    translate(-c.pos.x * repeatX + pos.x, pos.y);
    if (direction == 2){
      image(stemCrownImg, -35, -10);
      image(stemVineImg, -35, -10 + stemCrownImg.height / 2);
      image(stemVineImg, -35, -10 + stemCrownImg.height / 2 + stemVineImg.height);
      image(stemVineImg, -35, -10 + stemCrownImg.height / 2 + stemVineImg.height * 2);
       image(stemVineImg, -35, -10 + stemCrownImg.height / 2 + stemVineImg.height * 3);
        image(stemBaseImg, -35, -10 + stemCrownImg.height / 2 + stemVineImg.height * 4 - 15);
    }
    
    pushMatrix();
    rotate(radians(angle));

    image(imgs[0], -dim.x / 2, -dim.y / 2);
    for (int i = 0; i < tileAmount - 2; i++) {
      image(imgs[1], -dim.x / 2 + (i + 1) * imgs[0].width, -dim.y / 2);
    }
    image(imgs[imgs.length - 1], dim.x / 2 - imgs[0].width, -dim.y / 2);
    popMatrix();
    
    popMatrix();
    
    //pushMatrix();
    //translate(-c.pos.x * repeatX + pos.x, pos.y);
    
    //popMatrix();
  }
  

  //void drawMe(Character c) {
  //  noStroke();
  //  pushMatrix();
  //  translate(-c.pos.x * repeatX + pos.x, pos.y);
  //  rotate(radians(angle));
  //  noStroke();
  //  fill(50, 50, 50);
  //  rect(-dim.x/2, -dim.y/2, dim.x, dim.y);
  //  popMatrix();
  //}
  
   public void move(){
     pos.add(vel); 
     
     if (direction == 0){
       if (pos.x > originalPos.x + offset || pos.x < originalPos.x - offset){
        vel.x *= -1; 
       }
     }
     
     if (direction == 1){
       if (pos.y > originalPos.y + offset || pos.y < originalPos.y - offset){
        vel.y *= -1; 
       }
     }
     
     if (direction == 2){
       
       angle += angle_speed;
       
       if (angle > 20 || angle < -20){
        angle_speed *= -1; 
       }
     }
     
  }
  
  
}
class Player extends Character {
  //fields
  boolean jumping = false;
  int amountOfKey = 0;
  int amountOfCoin = 0;
  ArrayList<Bullet> bullets = new ArrayList<Bullet>();
  int imgState;

  boolean fire = true;

  //a constructor to initialize the fields above with initial values
  Player(PVector pos) {
    super(pos);
    this.pos = pos;
    vel = new PVector(); //must create instance

    damp = 0.8f;
    imgs = playerStandImgs;
    dim = new PVector(imgs[0].width, imgs[0].height);
    maxHealth = health = 100;
  }

  //update the physics for the character
   public void update() {

    super.update();

    if (block instanceof MovingBlock) {
      MovingBlock b = (MovingBlock)block;
      if (b.direction == 0) pos.add(new PVector(b.vel.x/3, b.vel.y));
      if (b.direction == 1) pos.add(new PVector(b.vel.x, b.vel.y));
    }

    if (pos.y + dim.y/2 > height + 100) { //when it goes off the longest block let it land on the floor
       health = 0;
       reset();
    }

    checkBullets();

    if (imgState == 0) {
      imgs = playerStandImgs;
    }

    if (imgState == 1) {
      imgs = playerWalkImgs;
    }

    if (imgState == 2) {
      imgs = playerJumpImgs;
      index = 0;
    }

    if (block instanceof MovingBlock) {
      MovingBlock b = (MovingBlock)block;
      if (b.angle > 0) player.move(new PVector(2, 0));
      if (b.angle < 0) player.move(new PVector(-2, 0));
    }

    if (block instanceof SpringBlock) {
      SpringBlock b = (SpringBlock)block;
      if (b.isOn(player)) {
        b.index = 1;
      } else b.index = 0;
      if (up) b.index = 0;
    }
  }

   public void checkBullets() {
    for (int i = 0; i < bullets.size(); i++) {
      Bullet b = bullets.get(i);
      b.drawMe();
      b.update();

      for (int j = 0; j < enemies.size(); j++) {
        Character e = enemies.get(j);
        if (b.hit(e) && e.deadCountdown == -1) {
          e.decreaseHealth(1);
          e.hitCountdown = 60;
          e.pos.x = e.pos.x;
          if (e.health == 0){
             e.dead(30);
             int n = PApplet.parseInt(random(1,3));
             for (int k = 0; k < n; k++){
               tokens.add(new Coin(e.block, new PVector(e.pos.x + k * 20, -100)));
             }
             
          }
          bullets.remove(b);
        }
      }
    }
  }

   public void jump(PVector upAcc) {
    move(upAcc);
    jumping = true;
  }

   public void landOn(Block b) {
    block = b;
    pos.y = b.pos.y - dim.y /2 - b.dim.y / 2;
    jumping = false;
    vel.y = 0;
  }

   public void fall() {
    vel.y *= -1;
  }


   public void drawMe() {
    if (hitCountdown % 2 == 0) {
      pushMatrix();
      
      if (!fire) translate(pos.x + random(-3, -2), pos.y);
      else translate(pos.x, pos.y);
      
      if (vel.x < 0) {
        scale(-1, 1);
      }

      image(imgs[index++ % imgs.length], -dim.x / 2, -dim.y / 2);
      
      image(playerGunImg, 0, -12);

      popMatrix();
    }
  }

   public void drawMe2() {
    pushMatrix();

    //scale(sc);
    MovingBlock b = (MovingBlock)block;
    translate(b.pos.x - pos.x * repeatX, b.pos.y);
    rotate(radians(b.angle));
    translate(relPos.x, relPos.y);
    if (vel.x > 0) scale(-1, 1);
    image(imgs[index++ % imgs.length], -dim.x / 2, -dim.y / 2);


    popMatrix();
  }

   public void fire() {
    if (fire) {
      PVector loc;
      if (vel.x >= 0)  loc = new PVector(pos.x + random(40, 50), pos.y + random(5, 10));
      else loc = new PVector(pos.x - random(40, 50), pos.y + random(5, 10));
      int dir;
      if (vel.x >= 0) dir = 1;
      else dir = -1;
      PVector speed = new PVector(5 * dir, 0);

      bullets.add(new Bullet(loc, speed, "player"));
      fire = false;
    }
  }

   public void decreaseHealth(float n) {
    super.decreaseHealth(n);
    if (health == 0) {
      playerLifeNum--;
      if (playerLifeNum == 0) {
        println("Game over");
      } else {
        health = maxHealth;
        reset();
      }
    }
  }
  
   public void reset(){
     pos = new PVector(20, 200); 
  }
  
}
class Snail extends Character {
  //fields

  //a constructor to initialize the fields above with initial values
  Snail(Block b, PVector rp) {
    super(rp);
    damp = 1;
    this.block = b;
    vel = new PVector(random(-0.5f, 0.5f), 0); //must create instance
    imgs = snailImgs;
    dim = new PVector(imgs[0].width, imgs[0].height);
    health = 1;
    sc = random(1, 1.5f);
  }

  //update the physics for the character
   public void update() {
    super.update();
    
    if (pos.x + dim.x / 2 > block.dim.x / 2 || pos.x - dim.x / 2 < -block.dim.x / 2) {
      vel.x *= -1;
    }
  }


   public void drawMe(Character c) {
    if (hitCountdown % 2 == 0){
      pushMatrix();
      translate(-c.pos.x*repeatX+block.pos.x, block.pos.y);
      translate(pos.x, pos.y); //relative position to block stand on
      scale(sc);
      if (deadCountdown > 0) scale(map(deadCountdown, 0, 30, 0, 1));
      if (vel.x > 0) scale(-1, 1);
      
      if (frameCount % 8 == 0) index++;
      image(imgs[index%imgs.length], -dim.x / 2, -dim.y / 2);
      popMatrix();
    }
  }
}
class SpringBlock extends Block{
  int index;
  
  SpringBlock(PVector pos, int amount, PImage[] images) {
    super(pos, amount, images);
    
  }
 
   public void drawMe(Character c) {
    pushMatrix();
    translate(-c.pos.x * repeatX + pos.x, pos.y);
  
    image(imgs[index], -dim.x / 2, -dim.y / 2);
 
    popMatrix();
  }
}
class Sprite{
   PVector pos;
   PVector vel;
   PVector dim;
   int c;

  Sprite(PVector pos) {
    this.pos = pos;
    this.vel = new PVector(random(-3, 3), random(-3, 3));
    
    int size = PApplet.parseInt(random(5, 10));
    dim = new PVector(size,size);
    c = color(random(255), random(255), random(255));
  }

   public void drawMe() {
    pushMatrix();
    translate(pos.x, pos.y);
    fill(c);
    noStroke();
    ellipse(0, 0, dim.x, dim.y);
    popMatrix();
  }
  
   public void move(){
     pos.add(vel); 
     
  }
  
   public void update(){
     move();
     
     dim.sub(new PVector(0.2f, 0.2f));
     if (dim.x <= 0) dim.x= 0;
     if (dim.y <= 0) dim.y= 0;
  }
}
class Token {
  PVector relPos; //relative position of token with respect to the block b
  PVector originalRelPos; //relative position of token with respect to the block b
  PVector dim; //size of the token circle
  Block block;    //the block the token is positioned above
  int displayCountdown = -1;
  //float sc;
  
  PImage[] imgs;
  int index = 0;

  Token(Block b, PVector rp) {
    relPos = rp;
    originalRelPos = relPos.copy();
    this.block = b;
  }

   public void drawMe(Character c) {
    
  }

   public boolean collision(Character c) {
    float x = block.pos.x-c.pos.x * repeatX+relPos.x;
    float y = block.pos.y+relPos.y;
    //println(x, y, c.pos.x, c.pos.y);
    return dist(x, y, c.pos.x, c.pos.y) < dim.x/2+c.dim.y/2;
  }
  
   public void update(){
      if (frameCount % 10 == 0){
         index++; 
         if (index == imgs.length) index = 0;
      }
      
      if (displayCountdown > 0) displayCountdown--;
  }
  
   public void setDisplayCountdown(int n){
     displayCountdown = n;
  }
}
class WaterBlock extends Block{
  WaterBlock(PVector pos, int amount, PImage[] images) {
    super(pos,amount, images);
    
  }
  

   public void drawMe(Character c) {
    noStroke();
    pushMatrix();
    translate(-c.pos.x * repeatX + pos.x, pos.y);
    //if (frameCount % 10 == 0){
    //   scale(-1, 1); 
    //}
    noStroke();
    fill(50, 50, 50);
  
   pushStyle();
      tint(255, 200);
    image(imgs[0], -dim.x / 2, -dim.y / 2);
    for (int i = 0; i < tileAmount - 2; i++){
      image(imgs[1], -dim.x / 2 + (i + 1) * imgs[0].width, -dim.y / 2);
    }
    image(imgs[imgs.length - 1], dim.x / 2 - imgs[0].width, -dim.y / 2);
    noFill();
    stroke(0);
    //rect(-dim.x  /2, -dim.y / 2, dim.x, dim.y);
   popStyle();
    popMatrix();
  }
}
class DisintegrateBlock extends Block{
  boolean solid;
  int alpha;
  int countdown;
  
  DisintegrateBlock(PVector pos, int amount, PImage[] images) {
    super(pos, amount, images);
    solid = false;
    alpha = 80;
  }
  

   public void drawMe(Character c) {
    noStroke();
    pushMatrix();
    translate(-c.pos.x * repeatX + pos.x, pos.y);
    noStroke();
    if (solid) alpha = 255;
    else alpha = 80;
    fill(255,0,0, alpha);
    
    rect(-dim.x/2, -dim.y/2, dim.x, dim.y);
    fill(0);
    if (solid) text(countdown / 60 + 1, 0, 0);
    popMatrix();
  }
  
   public void update(){
    //println(countdown);
    if (countdown > 0){
       countdown--;
       if (countdown == 0){
         solid = false;
         player.jumping = true;
       }
    }
  }
  
}
 public void keyPressed() {
  if (key == CODED) {
    if (keyCode == UP) {
      player.imgState = 2;
      up = true;
      jumpSound.play(0);
    } else if (keyCode == LEFT) {
      player.imgState = 1;
      left = true;
    } else if (keyCode == RIGHT) {
      player.imgState = 1;
      right = true;
    }
  }

  if (key == ' ') {
    player.fire();
  }

  if (key == 'k' || key == 'K') {
    if (player.amountOfKey > 0) {
      player.amountOfKey--;
      for (int i = 0; i < blocks.size(); i++) {
        Block b = blocks.get(i);
        if (b instanceof DisintegrateBlock) {
          ((DisintegrateBlock)b).solid = true;
          ((DisintegrateBlock)b).countdown = 180;
        }
      }
    }
  }
}

 public void keyReleased() {
  if (key == CODED) {
    if (keyCode == UP) {
      player.imgState = 0;
      up = false;
    } else if (keyCode == LEFT) {
      player.imgState = 0;
      left = false;
    } else if (keyCode == RIGHT) {
      player.imgState = 0;
      right = false;
    }
  }

  if (!player.fire) {
    player.fire = true;
    fireSound.play(0);
  }
}


  public void settings() { size(1000, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "platformerSroll3" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
